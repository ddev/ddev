#ddev-generated
# Example DDEV-Live provider configuration.

# To use this configuration,
# 1. Get your DDEV-Live API token on the [DDEV Dashboar](https://dash.ddev.com/settings/integration).
# 2. Using either `ddev-live` on the host or in the web container, authenticate and create a database backup, `ddev-live create backup database <sitename>`
# 3. Place the database backup name in the `database_backup:` below
# 4. Create a files backup using `ddev-live create backup files <sitename>`
# 5. Add add an entry to web_environment in ~/.ddev/global_config.yaml with the token:
# web_environment:
# - DDEV_LIVE_API_TOKEN=xxxxxxxx
# 6. Copy ddev-live.yaml.example to ddev-live.yaml.
# 7. Update project_id and database_backup.
# 8. `ddev restart`
# 9. Use `ddev pull ddev-live` to pull the project database and files.

# Debugging: Use `ddev exec ddev-live list sites` and `ddev exec ddev-live list backups`

environment_variables:
  project_id: rfay/d9demo
  database_backup: rfay/d9demo-7vrl2
  org: rfay

auth_command:
  command: |
    # set -x   # You can enable bash debugging output by uncommenting
    #if ! command -v drush >/dev/null ; then echo "Please make sure your project contains drush, ddev composer require drush/drush" && exit 1; fi
    if [ -z "${DDEV_LIVE_API_TOKEN:-}" ]; then echo "Please make sure you have set DDEV_LIVE_API_TOKEN in ~/.ddev/global_config.yaml" && exit 1; fi
    ddev-live auth --token="${DDEV_LIVE_API_TOKEN}"

db_pull_command:
  command: |
    # set -x   # You can enable bash debugging output by uncommenting
    pushd /var/www/html/.ddev/.downloads >/dev/null
    ddev-live pull database ${database_backup}
    mv "${database_backup#*/}.sql.gz" db.sql.gz

files_pull_command:
  command: |
    # set -x   # You can enable bash debugging output by uncommenting
    ls /var/www/html/.ddev >/dev/null # This just refreshes stale NFS if possible
    pushd /var/www/html/.ddev/.downloads >/dev/null;
    ddev-live pull files ${project_id} --dest=files/ >/dev/null 2>&1

# push is a dangerous command. If not absolutely needed it's better to delete these lines.
db_push_command:
  command: |
    # set -x   # You can enable bash debugging output by uncommenting
    if ! command -v jq; then echo "Please install jq to use this, brew install jq"; fi
    ls /var/www/html/.ddev >/dev/null # This just refreshes stale NFS if possible
    pushd /var/www/html/.ddev/.downloads >/dev/null;
    restore=$(ddev-live push database ${project_id} -o json db.sql.gz | jq -r .databaseRestore)
    while true; do
        restore_status=$(ddev-live describe restore database "${project_id%/*}/$restore" -o json | jq -r .status)
        if [ "${restore_status}" = "ImportOpFinished" ]; then break; fi
        sleep 1
    done

# push is a dangerous command. If not absolutely needed it's better to delete these lines.
files_push_command:
  command: |
    # set -x   # You can enable bash debugging output by uncommenting
    ls ${DDEV_FILES_DIR} >/dev/null # This just refreshes stale NFS if possible
    pushd $DDEV_FILES_DIR >/dev/null;
    restore=$(ddev-live push files ${project_id} -o json . 2>/dev/null | jq -r .filesRestore)
    while true; do
        restore_status=$(ddev-live describe restore files "${project_id%/*}/${restore}" -o json | jq -r .complete)
        if [ "${restore_status}" = "Completed" ]; then break; fi
        sleep 1
    done
